#' Create boundary matrix for prioritizr if you are using patches
#'
#' @description This function creates a boundary matrix to plug into prioritizr
#'
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `offshoredatr::get_planning_grid()`; values in areas of interest are 1, while all other values are NA (only required if feature is a sf object)
#' @param patches a raster or sf object generated by `create_patches()`; a single feature split into spatially distinct groups; each layer of the raster or each column of the sf object identifies the location of each patch
#' @param patch_df a dataframe generated by `create_patch_df()` that includes constraints for each patch and grid cell combination
#'
#' @return A boundary matrix to plug into prioritizr
#' @export
#'
#' @examples
#'# Start with a little housekeeping to get the data from oceandatr
#'# Choose area of interest (Bermuda EEZ)
#'area <- oceandatr::get_area(area_name = "Bermuda")
#'projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'
#'# Create a planning grid
#'planning_raster <- oceandatr::get_planning_grid(area, projection = projection)
#'# Grab all relevant data
#'features_raster <- oceandatr::get_features(planning_grid = planning_raster)
#'# Separate seamount data - we want to protect entire patches
#'seamounts_raster <- features_raster[["seamounts"]]
#'features_raster <- features_raster[[names(features_raster)[names(features_raster) != "seamounts"]]]
#'# Create a "cost" to protecting a cell - just a uniform cost for this example
#'cost_raster <- stats::setNames(planning_raster, "cost")
#'# Create patches from layer
#'patches_raster <- create_patches(seamounts_raster)
#'# Create patch dataframe
#'patches_raster_df <- create_patch_df(planning_grid = planning_raster, features = features_raster,
#'   patches = patches_raster, costs = cost_raster)
#'# Create boundary matrix for prioritizr
#'boundary_matrix <- create_boundary_matrix(planning_grid = planning_raster,
#'   patches = patches_raster, patch_df = patches_raster_df)

create_boundary_matrix <- function(planning_grid, patches, patch_df){

  # Add error for incorrect format of feature
  if(!check_raster(planning_grid) & !check_sf(planning_grid)) { stop("planning_grid must be a raster or sf object")}
  if(!check_raster(patches) & !check_sf(patches)) { stop("patches must be a raster or sf object")}
  if(!check_df(patch_df)) { stop("patch_df must be a dataframe object")}
  if(!check_matching_crs(planning_grid, patches)) { stop("planning_grid and patches must be of the same crs")}
  if(!check_matching_type(planning_grid, patches)) { stop("planning_grid and patches must be of the same object type (all raster or all sf)")}

  if(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")){
    patch_ids <- patch_df %>%
      dplyr::slice_tail(n = terra::nlyr(patches)) %>%
      dplyr::pull(1)

    planning_grid_sf <- terra::as.polygons(planning_grid, aggregate = FALSE, na.rm = FALSE) %>%
      sf::st_as_sf()

  } else {
    patch_ids <- patch_df %>%
      dplyr::slice_tail(n = ncol(patches %>% sf::st_drop_geometry())) %>%
      dplyr::pull(1)

    planning_grid_sf <- planning_grid
  }

  planning_unit_sf <-
    planning_grid_sf %>%
    sf::st_drop_geometry() %>%
    dplyr::mutate(geometry = sf::st_geometry(planning_grid_sf)) %>%
    sf::st_set_geometry(., "geometry") %>%
    dplyr::select(geometry) %>%
    dplyr::bind_rows(
      lapply(patch_ids, function(i) {
        sf::st_sf(layer = 1, geometry = sf::st_union(planning_grid_sf[i, , drop = FALSE]))
      }) %>%
        do.call(what = dplyr::bind_rows) %>%
        dplyr::select(-layer)
    )

  return(prioritizr::boundary_matrix(planning_unit_sf))
}
