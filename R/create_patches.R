#' Create patches for a specific feature
#'
#' @description This function takes a feature and splits it into multiple "patches" of the feature. This is ideal for features that you want to protect x% of, but want to make sure that entire patches (as opposed to pieces of patches) are protected to meet that target.
#'
#' @details
#'
#' @param feature a raster or sf object with the feature of interest present (value = 1) or absent (value = NA)
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#'
#' @return A raster or sf object with independent layers (raster)/columns (sf) designating the location of each patch
#' @export
#'
#' @examples

create_patches <- function(feature, planning_grid) {

  # Add error for incorrect format of feature
  if(!is.null(feature) & !(class(feature)[1] %in% c("RasterLayer", "SpatRaster", "sf"))) {
    stop("feature must be a raster or sf object")}

  if(class(feature)[1] %in% c("RasterLayer", "SpatRaster")) {
    feature <- feature %>%
      as("SpatRaster") %>%
      terra::patches() %>%
      terra::segregate(other = NA) %>%
      setNames(paste0("patches_", seq_len(terra::nlyr(.))))
  } else {
    feature <- feature %>%
      dplyr::rename(value = 1) %>%
      dplyr::filter(value == 1)

    feature_matrix <- sf::st_touches(feature, sparse = F)
    hc <- hclust(as.dist(!feature_matrix), method = "single")
    feature_groups <- cutree(hc, h = 0.5)

    suppressWarnings({
      feature <- feature %>%
        dplyr::mutate(patches = paste0("patches_", feature_groups)) %>%
        dplyr::mutate(value = 1) %>%
        tidyr::pivot_wider(names_from = "patches", values_from = "value") %>%
        sf::st_join(planning_grid %>% dplyr::select(geometry), ., largest = TRUE) %>%
        dplyr::select(colnames(.)[grepl("patches", colnames(.))])
    })
  }
  return(feature)
}
