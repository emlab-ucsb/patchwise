#' Converts prioritization solution into a more digestible output
#'
#' @description This function converts the prioritization solution that uses patches to a raster or sf object (depending on the format of your planning_grid) that clearly marks areas suggested for protection (1) and areas not suggested for protection (0)
#'
#' @param solution the solution that results from using `prioritizr::solve()` on `prioritizr::problem()`
#' @param patch_df a dataframe generated by `create_patch_df()` that includes constraints for each patch and grid cell combination
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `offshoredatr::get_planning_grid()`; values in areas of interest are 1, while all other values are NA (only required if feature is a sf object)
#'
#' @return A raster or sf object that denotes areas suggested for protection (value = 1)
#' @export
#'
#' @examples
#'# Start with a little housekeeping to get the data from oceandatr
#'# Choose area of interest (Bermuda EEZ)
#'area <- oceandatr::get_area(area_name = "Bermuda")
#'projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'
#'# Create a planning grid
#'planning_raster <- oceandatr::get_planning_grid(area, projection = projection)
#'# Grab all relevant data
#'features_raster <- oceandatr::get_features(planning_grid = planning_raster)
#'# Separate seamount data - we want to protect entire patches
#'seamounts_raster <- features_raster[["seamounts"]]
#'features_raster <- features_raster[[names(features_raster)[names(features_raster) != "seamounts"]]]
#'# Create a "cost" to protecting a cell - just a uniform cost for this example
#'cost_raster <- setNames(planning_raster, "cost")
#'# Create patches from layer
#'patches_raster <- create_patches(seamounts_raster)
#'# Create patch dataframe
#'patches_raster_df <- create_patch_df(planning_grid = planning_raster, features = features_raster, patches = patches_raster, costs = cost_raster)
#'# Create boundary matrix for prioritizr
#'boundary_matrix <- create_boundary_matrix(planning_grid = planning_raster, patches = patches_raster, patch_df = patches_raster_df)
#'# Create target features - using just 20% for every feature
#'features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1), features = features_raster, pre_patches = seamounts_raster)
#'# Create constraint targets
#'constraint_targets <- constraints_targets(feature_targets = features_targets, patch_df = patches_raster_df)
#'# Create prioritization problem
#'problem_raster <- prioritizr::problem(x = patches_raster_df, features = constraint_targets$feature, cost_column = "cost") %>% prioritizr::add_min_set_objective() %>% prioritizr::add_manual_targets(constraint_targets) %>% prioritizr::add_binary_decisions() %>% prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix) %>% prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)
#'# Solve problem
#'solution <- solve(problem_raster)
#'# Convert to a more digestible format
#'suggested_protection <- convert_solution(solution = solution, patch_df = patches_raster_df, planning_grid = planning_raster)

convert_solution <- function(solution, patch_df, planning_grid) {

  # Add error for incorrect format of feature
  if(!check_df(solution)) { stop("solution must be a dataframe")}
  if(!check_raster(planning_grid) & !check_sf(planning_grid)) { stop("planning_grid must be a raster or sf object")}
  if(!check_df(patch_df)) { stop("patch_df must be a dataframe object")}


  planning_unit_id <-  unique(unlist(patch_df$id[which(solution$solution_1 > 0.5)]))

  if(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")){
    solution <- planning_grid*0
    solution[planning_unit_id] <- 1
    setNames(solution, "protected")
  } else {
    solution <- planning_grid %>%
      sf::st_drop_geometry() %>%
      dplyr::mutate(geometry = sf::st_geometry(planning_grid)) %>%
      sf::st_set_geometry(., "geometry") %>%
      dplyr::select(geometry) %>%
      dplyr::mutate(protected = 0)

    solution[planning_unit_id,"protected"] <- 1
  }
  return(solution)
}
