#' Create a dataframe that counts each patch independently for the prioritizr input
#'
#' @description This function takes all of the inputs of prioritizr and creates a dataframe precursor for prioritizr. This specific function includes the use of "patches" which have been already generated by `create_patches()`. "Patches" are spatial groups of a particular feature, such as seamounts. Prioritizr will protect entire patches to meet the protection goal for that feature. The output of this function should be passed to `create_boundary_matrix()` before being passed to prioritizr.
#'
#' @param spatial_grid a raster or sf template with the desired resolution and coordinate reference system generated by `spatialgridr::get_grid()`; values in areas of interest are 1, while all other values are NA
#' @param features a raster or sf object that includes all relevant features to be used in the prioritization; each layer of the raster or each column of the sf object identifies the location of each feature
#' @param patches a raster or sf object generated by `create_patches()`; a single feature split into spatially distinct groups; each layer of the raster or each column of the sf object identifies the location of each patch
#' @param costs a raster or sf object of the costs for protecting each cell in the planning grid
#' @param locked_out a raster or sf object for areas to be locked out (absolutely not protected) in the prioritization
#' @param locked_in a raster or sf object for areas to be locked in (absolutely protected) in the prioritization
#'
#' @return A data frame to be used as an input for `create_boundary_matrix()`
#' @importFrom rlang :=
#' @export
#'
#' @examples
#'# Start with a little housekeeping to get the data from oceandatr
#'# Choose area of interest (Bermuda EEZ)
#'area <- oceandatr::get_area(area_name = "Bermuda",  mregions_column = "territory1")
#'projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'
#'# Create a planning grid
#'planning_raster <- spatialgridr::get_grid(area, projection = projection)
#'# Grab all relevant data
#'features_raster <- oceandatr::get_features(spatial_grid = planning_raster)
#'# Separate seamount data - we want to protect entire patches
#'seamounts_raster <- features_raster[["seamounts"]]
#'features_raster <- features_raster[[names(features_raster)[names(features_raster) != "seamounts"]]]
#'# Create a "cost" to protecting a cell - just a uniform cost for this example
#'cost_raster <- stats::setNames(planning_raster, "cost")
#'# Create patches from layer
#'patches_raster <- create_patches(seamounts_raster)
#'# Create patch dataframe
#'patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,
#'   patches = patches_raster, costs = cost_raster)

create_patch_df <- function(spatial_grid, features, patches, costs = NULL, locked_out = NULL, locked_in = NULL){

  # Add error for incorrect format of feature
  if(!check_raster(spatial_grid) & !check_sf(spatial_grid)) { stop("spatial_grid must be a raster or sf object")}
  if(!check_raster(patches) & !check_sf(patches)) { stop("patches must be a raster or sf object")}
  if(!check_raster(features) & !check_sf(features)) { stop("features must be a raster or sf object")}
  if(!(check_matching_crs(spatial_grid, features) | !check_matching_crs(spatial_grid, patches))) { stop("spatial_grid, features, and patches must be of the same crs")}
  if(!(check_matching_type(spatial_grid, features) | !check_matching_type(spatial_grid, patches))) { stop("spatial_grid, features, and patches must be of the same object type (all raster or all sf)")}

  # Find which optional objects were supplied, an make sure they are in the right format
  supplied <- NULL
  for(options in c("costs", "locked_out", "locked_in")) {
    if(!is.null(get(options))) {
      supplied <- c(supplied, options)
      if(!(identical(class(spatial_grid), class(get(options))))) {
        stop("features, patches, costs, locked out, and locked in objects must be of the same class")
        }
      }
  }

  if("locked_in" %in% supplied) { names(locked_in)[1] <- "locked_in" }
  if("locked_out" %in% supplied) { names(locked_out)[1] <- "locked_out" }

  if (class(spatial_grid)[1] %in% c("RasterLayer", "SpatRaster")) {
    # Initialize
    pu_grid_data <- tibble::tibble(id = as.list(seq_len(nrow(terra::as.data.frame(spatial_grid, na.rm = FALSE))))) %>%
      dplyr::bind_cols(tibble::tibble(terra::as.data.frame(features, na.rm = FALSE))) %>%
      dplyr::mutate(patch = 0)

    if(!is.null(supplied)) {
      for(options in supplied) {
        pu_grid_data <- pu_grid_data %>%
          dplyr::bind_cols(tibble::tibble(terra::as.data.frame(get(options), na.rm = FALSE)))
        }
      }

    # Create planning units at the patch level
    pu_sm_data <- lapply(names(patches), function(i) {
      curr_sm_pu <-
        tibble::tibble(
          id = list(as.numeric(row.names(terra::as.data.frame(patches[[i]], na.rm = FALSE))[which(terra::as.data.frame(patches[[i]], na.rm = FALSE) > 0.5)]))) %>%
       dplyr::bind_cols(
          terra::as.data.frame(features * patches[[i]], na.rm = FALSE) %>%
            stats::setNames(names(features)) %>%
            dplyr::summarize_all(sum, na.rm = TRUE)
        )

      if(!is.null(supplied)) {
        for(options in supplied) {
          if(grepl("locked", options)) {
            curr_sm_pu <- curr_sm_pu %>%
              dplyr::bind_cols(
                terra::as.data.frame(get(options) * patches[[i]], na.rm = FALSE) %>%
                  sum(na.rm = TRUE) %>%
                  {data.frame(value = ifelse(. > 0, 1, 0)) %>%
                      dplyr::rename(!!options := value)})
          } else {
          curr_sm_pu <- curr_sm_pu %>%
            dplyr::bind_cols(
              terra::as.data.frame(get(options) * patches[[i]], na.rm = FALSE) %>%
                stats::setNames(names(get(options))) %>%
                dplyr::summarize_all(sum, na.rm=TRUE))
          }
        }
      }

      curr_sm_pu <- curr_sm_pu %>%
        dplyr::mutate(
          patch = sum(terra::values(patches[[i]]), na.rm = T)
        )
      curr_sm_pu
    }
    ) %>%
      do.call(what = dplyr::bind_rows) %>% tibble::as_tibble()

    if("locked_out" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_out, .after = tidyselect::last_col())
    }
    if("locked_in" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_in, .after = tidyselect::last_col())
    }

  } else {
    # Drop all geometries
    features <- features %>% sf::st_drop_geometry()

    for(options in supplied) {
      temp <- get(options) %>% sf::st_drop_geometry()
      assign(options, temp)
    }

    # Initialize
    pu_grid_data <- tibble::tibble(id = as.list(seq_len(nrow(spatial_grid)))) %>%
      dplyr::bind_cols(features) %>%
      dplyr::mutate(patch = 0)

    if(!is.null(supplied)) {
      for(options in supplied) {
        pu_grid_data <- pu_grid_data %>%
          dplyr::bind_cols(tibble::tibble(terra::as.data.frame(get(options), na.rm = FALSE)))
      }
    }

    patches <- patches %>% sf::st_drop_geometry()

    # Create planning units at the patch level
    pu_sm_data <- lapply(names(patches), function(i) {
      curr_sm_pu <-
        tibble::tibble(
          id = list(as.numeric(row.names(patches[which(patches[,i] > 0.5),])))) %>%
        dplyr::bind_cols(data.frame(t(features %>% dplyr::mutate_all(., ~(.*patches[,i])) %>%
                                        colSums(., na.rm = T))))

      if(!is.null(supplied)) {
        for(options in supplied) {
          curr_sm_pu <- curr_sm_pu %>%
              dplyr::bind_cols(data.frame(t(get(options) %>% dplyr::mutate_all(., ~(.*patches[,i])) %>%
                                              colSums(., na.rm = T))))
        }
      }

      curr_sm_pu <- curr_sm_pu %>%
        dplyr::mutate(
          patch = sum(patches[,i], na.rm = T)
        )
      curr_sm_pu
    }
    ) %>%
      do.call(what = dplyr::bind_rows) %>% tibble::as_tibble()

    if("locked_out" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_out, .after = tidyselect::last_col())
    }
    if("locked_in" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_in, .after = tidyselect::last_col())
    }
  }

  # Merge patch-level data and grid-cell level data together
  pu_data <-  dplyr::bind_rows(pu_grid_data, pu_sm_data)

  # Constraints so the solution doesn't select overlapping grid cell and patch level
  # planning units
  constraints <- data.frame(test  = rep(0,nrow(pu_data)))

  index <- 1

  #Create a vector with a '1' for each combination of patch-level
  # and grid-cell level planning unit that overlaps with that patch.
  for (i in seq_len(nrow(pu_sm_data))) {
    print(paste0("Processing patch ", i, " of ", nrow(pu_sm_data)))

    for (j in pu_sm_data$id[[i]]) {
      v <- rep(0, nrow(pu_data)) # initialize with zeros
      v[nrow(pu_grid_data) + i] <- 1  # specify patch-level planning unit
      v[as.numeric(j)] <- 1 # specify grid cell-level planning unit

      constraints <- cbind(constraints, v)
      index <- index+1
    }
  }

  constraints <- constraints[, -1] # remove dummy row

  pu_data_final <- constraints %>%
    stats::setNames(sprintf("constraint_%d", seq.int(1:ncol(.)))) %>%
    dplyr::bind_cols(pu_data, .)

  return(pu_data_final)
}
