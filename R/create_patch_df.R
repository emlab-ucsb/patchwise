#' Create a dataframe that counts each patch independently for the prioritizr input
#'
#' @description This function takes all of the inputs of prioritizr and creates a dataframe precursor for prioritizr. This specific function includes the use of "patches" which have been already generated by `create_patches()`. "Patches" are spatial groups of a particular feature, such as seamounts. Prioritizr will protect entire patches to meet the protection goal for that feature. The output of this function should be passed to `create_boundary_matrix()` before being passed to prioritizr.
#'
#' @param planning_grid a raster or sf template with the desired resolution and coordinate reference system generated by `offshoredatr::get_planning_grid()`; values in areas of interest are 1, while all other values are NA
#' @param features a raster or sf object that includes all relevant features to be used in the prioritization; each layer of the raster or each column of the sf object identifies the location of each feature
#' @param patches a raster or sf object generated by `create_patches()`; a single feature split into spatially distinct groups; each layer of the raster or each column of the sf object identifies the location of each patch
#' @param costs a raster or sf object of the costs for protecting each cell in the planning grid
#' @param locked_out a raster or sf object for areas to be locked out (absolutely not protected) in the prioritization
#' @param locked_in a raster or sf object for areas to be locked in (absolutely protected) in the prioritization
#'
#' @return A data frame to be used as an input for `create_boundary_matrix()`
#' @export
#'
#' @examples
#' ## To be updated later
#' # Create patches from seamount raster data
#' seamount_patches <- create_patches(seamount_raster)
#' # Create dataframe from patches
#' patches_df <- create_patch_df(planning_grid = planning_raster, features = features_raster, patches = seamount_patches)

create_patch_df <- function(planning_grid, features, patches, costs = NULL, locked_out = NULL, locked_in = NULL){

  # Add repeated errors for planning_grid (present in nearly all functions)
  if(!is.null(planning_grid) & !(class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster", "sf"))) {
    stop("planning_grid must be a raster or sf object")}

  # Make sure all the features are in the same format
  if(!(identical(class(planning_grid), class(features)) &
       identical(class(features), class(patches)))) {
    stop("features, patches, costs, locked out, and locked in objects must be of the same class")
  }

  # Find which optional objects were supplied, an make sure they are in the right format
  supplied <- NULL
  for(options in c("costs", "locked_out", "locked_in")) {
    if(!is.null(get(options))) {
      supplied <- c(supplied, options)
      if(!(identical(class(planning_grid), class(get(options))))) {
        stop("features, patches, costs, locked out, and locked in objects must be of the same class")
        }
      }
  }

  if (class(planning_grid)[1] %in% c("RasterLayer", "SpatRaster")) {
    # Initialize
    pu_grid_data <- tibble::tibble(id = as.list(seq_len(nrow(terra::as.data.frame(planning_grid))))) %>%
      dplyr::bind_cols(tibble::tibble(terra::as.data.frame(features))) %>%
      dplyr::mutate(patch = 0)

    if(!is.null(supplied)) {
      for(options in supplied) {
        pu_grid_data <- pu_grid_data %>%
          dplyr::bind_cols(tibble::tibble(terra::as.data.frame(get(options))))
        }
      }

    # Create planning units at the patch level
    pu_sm_data <- lapply(names(patches), function(i) {
      curr_sm_pu <-
        tibble::tibble(
          id = list(as.numeric(row.names(terra::as.data.frame(patches[[i]]))[which(terra::as.data.frame(patches[[i]]) > 0.5)]))) %>%
       dplyr::bind_cols(
          terra::as.data.frame(features * patches[[i]]) %>%
            setNames(names(features)) %>%
            dplyr::summarize_all(sum, na.rm = TRUE)
        )

      if(!is.null(supplied)) {
        for(options in supplied) {
          if(grepl("locked", options)) {
            curr_sm_pu <- curr_sm_pu %>%
              dplyr::bind_cols(
                terra::as.data.frame(get(options) * patches[[i]]) %>%
                  sum(na.rm = TRUE) %>%
                  {data.frame(value = ifelse(. > 0, 1, 0)) %>%
                      dplyr::rename(!!options := value)})
          } else {
          curr_sm_pu <- curr_sm_pu %>%
            dplyr::bind_cols(
              terra::as.data.frame(get(options) * patches[[i]]) %>%
                setNames(names(get(options))) %>%
                dplyr::summarize_all(sum, na.rm=TRUE))
          }
        }
      }

      curr_sm_pu <- curr_sm_pu %>%
        dplyr::mutate(
          patch = sum(terra::values(patches[[i]]), na.rm = T)
        )
      curr_sm_pu
    }
    ) %>%
      do.call(what = dplyr::bind_rows) %>% tibble::as_tibble()

    if("locked_out" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_out, .after = last_col())
    }
    if("locked_in" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_in, .after = last_col())
    }

  } else {
    # Drop all geometries
    features <- features %>% sf::st_drop_geometry()

    for(options in supplied) {
      temp <- get(options) %>% sf::st_drop_geometry()
      assign(options, temp)
    }

    # Initialize
    pu_grid_data <- tibble::tibble(id = as.list(seq_len(nrow(planning_grid)))) %>%
      dplyr::bind_cols(features) %>%
      dplyr::mutate(patch = 0)

    if(!is.null(supplied)) {
      for(options in supplied) {
        pu_grid_data <- pu_grid_data %>%
          dplyr::bind_cols(tibble::tibble(terra::as.data.frame(get(options))))
      }
    }

    patches <- patches %>% sf::st_drop_geometry()

    # Create planning units at the patch level
    pu_sm_data <- lapply(names(patches), function(i) {
      curr_sm_pu <-
        tibble::tibble(
          id = list(as.numeric(row.names(patches[which(patches[,i] > 0.5),])))) %>%
        dplyr::bind_cols(data.frame(t(features %>% dplyr::mutate_all(., ~(.*patches[,i])) %>%
                                        colSums(., na.rm = T))))

      if(!is.null(supplied)) {
        for(options in supplied) {
          curr_sm_pu <- curr_sm_pu %>%
              dplyr::bind_cols(data.frame(t(get(options) %>% dplyr::mutate_all(., ~(.*patches[,i])) %>%
                                              colSums(., na.rm = T))))
        }
      }

      curr_sm_pu <- curr_sm_pu %>%
        dplyr::mutate(
          patch = sum(patches[,i], na.rm = T)
        )
      curr_sm_pu
    }
    ) %>%
      do.call(what = dplyr::bind_rows) %>% tibble::as_tibble()

    if("locked_out" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_out, .after = last_col())
    }
    if("locked_in" %in% supplied) {
      pu_sm_data <- pu_sm_data %>%
        dplyr::relocate(locked_in, .after = last_col())
    }
  }

  # Merge patch-level data and grid-cell level data together
  pu_data <-  dplyr::bind_rows(pu_grid_data, pu_sm_data)

  # Constraints so the solution doesn't select overlapping grid cell and patch level
  # planning units
  constraints <- data.frame(test  = rep(0,nrow(pu_data)))

  index <- 1

  #Create a vector with a '1' for each combination of patch-level
  # and grid-cell level planning unit that overlaps with that patch.
  for (i in seq_len(nrow(pu_sm_data))) {
    print(paste0("Processing patch ", i, " of ", nrow(pu_sm_data)))

    for (j in pu_sm_data$id[[i]]) {
      v <- rep(0, nrow(pu_data)) # initialize with zeros
      v[nrow(pu_grid_data) + i] <- 1  # specify patch-level planning unit
      v[as.numeric(j)] <- 1 # specify grid cell-level planning unit

      constraints <- cbind(constraints, v)
      index <- index+1
    }
  }

  constraints <- constraints[, -1] # remove dummy row

  pu_data_final <- constraints %>%
    setNames(sprintf("constraint_%d", seq.int(1:ncol(.)))) %>%
    dplyr::bind_cols(pu_data, .)

  return(pu_data_final)
}
