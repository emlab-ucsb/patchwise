[{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA. Map potential locked-areas. Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Map proposed solution locked-areas. areas green selected prioritization protection. can clearly see locked-area (green square) included!","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]] # Create a function to produce a square area create_area <- function(spatial_grid, mpa_size, edge_offset) {   if(class(spatial_grid)[1] %in% c(\"RasterLayer\", \"SpatRaster\")) {     terra::rast(spatial_grid,                 vals = c(rep(NA, (terra::ncol(spatial_grid)*edge_offset)),                          rep(c(rep(NA, edge_offset),                                rep(1, mpa_size),                                rep(NA, (terra::ncol(spatial_grid)-(edge_offset+mpa_size)))),                              mpa_size),                          rep(NA, (terra::ncol(spatial_grid)*(terra::nrow(spatial_grid)-edge_offset-mpa_size)))))   } else if(class(spatial_grid)[1] == \"sf\") {     sf_to_grid <- sf::st_make_grid(spatial_grid, cellsize = sqrt(sf::st_area(spatial_grid[1,])))     sf_centroid <- sf::st_centroid(sf_to_grid) %>%       sf::st_coordinates(.) %>%       as.data.frame() %>%       dplyr::mutate(X = round(X, digits = 4),                     Y = round(Y, digits = 4))      # sf::st_make_grid changes the orientation of how cells are read - change them back     sf_to_grid <- sf_to_grid %>%       as.data.frame() %>%       dplyr::bind_cols(sf_centroid) %>%       dplyr::arrange(dplyr::desc(Y), X) %>%       dplyr::select(-X, -Y)      cols_sf_to_grid <- length(unique(sf_centroid$X))     rows_sf_to_grid <- length(unique(sf_centroid$Y))      sf_to_grid <- sf_to_grid %>%       sf::st_sf() %>%       dplyr::mutate(layer = c(rep(NA, (cols_sf_to_grid*edge_offset)),                          rep(c(rep(NA, edge_offset),                                rep(1, mpa_size),                                rep(NA, (cols_sf_to_grid-(edge_offset+mpa_size)))),                              mpa_size),                          rep(NA, (cols_sf_to_grid*(rows_sf_to_grid-edge_offset-mpa_size)))))      # the planning sf only includes polygons for the planning area (we need to remove them) so the number of cells matches the planning grid     sf_to_grid <- sf_to_grid[sf_to_grid$geometry %in% spatial_grid[[1]], ]     rownames(sf_to_grid) <- NULL     sf_to_grid %>%       dplyr::relocate(layer, 1)     } } # Create a fake MPA mpa_location <- create_area(planning_rast, 20, 50)  # Plot fake MPA terra::plot(mpa_location) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214386 nonzeros #> Model fingerprint: 0xc25c3da2 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3740.9750000 #> Presolve removed 2915 rows and 1615 columns #> Presolve time: 0.64s #> Presolved: 73381 rows, 54458 columns, 207121 nonzeros #> Variable types: 0 continuous, 54458 integer (54458 binary) #> Root relaxation presolved: 73381 rows, 54458 columns, 207121 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    75523    3.7292125e+03   0.000000e+00   4.676925e+03      5s #>    88193    3.7247051e+03   0.000000e+00   1.152036e+03     10s #>    92763    3.7233916e+03   0.000000e+00   6.880988e+03     15s #>    97523    3.7230699e+03   0.000000e+00   1.977410e+03     20s #>   103193    3.7230205e+03   0.000000e+00   4.106123e+04     25s #>   109387    3.7228462e+03   0.000000e+00   3.799363e+04     30s #>   113716    3.7228405e+03   0.000000e+00   5.063170e+02     35s #>   117511    3.7228325e+03   0.000000e+00   5.532806e+03     40s #>   119951    3.7228309e+03   0.000000e+00   1.711754e+03     45s #>   122461    3.7228286e+03   0.000000e+00   1.202599e+03     50s #> Concurrent spin time: 0.04s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    69647    3.7229317e+03   0.000000e+00   0.000000e+00     51s #>  #> Root relaxation: objective 3.722932e+03, 69647 iterations, 50.41 seconds (151.93 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3722.93174    0 50601 3740.97500 3722.93174  0.48%     -   51s #>  #> Explored 1 nodes (69735 simplex iterations) in 51.50 seconds (153.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3740.98  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.740975000000e+03, best bound 3.722931735863e+03, gap 0.4823%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results. Map potential locked-areas. Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Map proposed solution locked-areas. Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_rast, 20, 95)  # Plot fake locked-out area terra::plot(no_protection) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214385 nonzeros #> Model fingerprint: 0xf7b92fc5 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3733.8850000 #> Presolve removed 2633 rows and 1557 columns #> Presolve time: 0.57s #> Presolved: 73663 rows, 54516 columns, 207723 nonzeros #> Variable types: 0 continuous, 54516 integer (54516 binary) #> Root relaxation presolved: 73663 rows, 54516 columns, 207723 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    80813    3.7266671e+03   0.000000e+00   1.275446e+03      5s #>    89493    3.7240545e+03   0.000000e+00   1.496065e+03     10s #>    94678    3.7234499e+03   0.000000e+00   1.518754e+03     15s #>    98708    3.7226503e+03   0.000000e+00   1.557963e+03     20s #>   103033    3.7218083e+03   0.000000e+00   2.200248e+03     25s #>   108113    3.7216433e+03   0.000000e+00   7.935639e+03     30s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    55179    3.7213346e+03   0.000000e+00   0.000000e+00     35s #>  #> Root relaxation: objective 3.721335e+03, 55179 iterations, 34.54 seconds (101.60 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3721.33461    0 49528 3733.88500 3721.33461  0.34%     -   35s #>  #> Explored 1 nodes (55285 simplex iterations) in 35.60 seconds (103.27 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3733.89  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.733885000000e+03, best bound 3.721335000000e+03, gap 0.3361%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas. Map proposed solution locked-locked-areas. looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76297 rows, 56073 columns and 214786 nonzeros #> Model fingerprint: 0x8acc3e12 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3741.0600000 #> Presolve removed 4596 rows and 2855 columns #> Presolve time: 0.63s #> Presolved: 71701 rows, 53218 columns, 202309 nonzeros #> Variable types: 0 continuous, 53218 integer (53218 binary) #> Root relaxation presolved: 71701 rows, 53218 columns, 202309 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    78109    3.7276375e+03   0.000000e+00   1.808055e+03      5s #>    86897    3.7269661e+03   0.000000e+00   3.529364e+02     10s #>    97327    3.7256267e+03   0.000000e+00   1.437909e+03     15s #>   107276    3.7231045e+03   0.000000e+00   3.567818e+03     20s #>   111807    3.7230532e+03   0.000000e+00   3.981599e+03     25s #>   116500    3.7230355e+03   0.000000e+00   4.431877e+03     30s #>   119866    3.7230222e+03   0.000000e+00   2.720234e+03     35s #>   123492    3.7230029e+03   0.000000e+00   8.703959e+03     40s #>   126136    3.7229923e+03   0.000000e+00   3.281546e+03     45s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    64341    3.7230710e+03   0.000000e+00   0.000000e+00     49s #>  #> Root relaxation: objective 3.723071e+03, 64341 iterations, 48.49 seconds (144.87 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3723.07098    0 49364 3741.06000 3723.07098  0.48%     -   49s #>  #> Explored 1 nodes (64433 simplex iterations) in 49.59 seconds (146.66 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3741.06  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.741060000000e+03, best bound 3.723070980814e+03, gap 0.4809%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA. Map potential locked-areas. Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Map proposed solution locked-areas. areas yellow selected prioritization protection. can clearly see locked-area (yellow square) included!","code":"# Create a fake MPA mpa_location <- create_area(planning_sf, 20, 50)  # Plot fake MPA plot(mpa_location, main = NULL, border = F) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218036 nonzeros #> Model fingerprint: 0xfea2ae20 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8950000 #> Presolve removed 2637 rows and 1617 columns #> Presolve time: 0.85s #> Presolved: 74344 rows, 54553 columns, 211669 nonzeros #> Variable types: 0 continuous, 54553 integer (54553 binary) #> Found heuristic solution: objective 3732.8900000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 74010 rows, 54553 columns, 210667 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    73906    3.7232193e+03   0.000000e+00   2.534610e+03      5s #>    84130    3.7226720e+03   0.000000e+00   1.378961e+04     10s #>    91314    3.7213965e+03   0.000000e+00   5.732673e+03     15s #>    96380    3.7208580e+03   0.000000e+00   9.779234e+02     20s #>   101294    3.7206395e+03   0.000000e+00   1.848140e+03     25s #>   107134    3.7200285e+03   0.000000e+00   1.159798e+03     30s #>   113612    3.7199862e+03   0.000000e+00   2.998862e+03     35s #>   117246    3.7199741e+03   0.000000e+00   1.646831e+03     40s #>   120256    3.7199589e+03   0.000000e+00   6.978084e+02     45s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    58008    3.7200450e+03   0.000000e+00   0.000000e+00     50s #>  #> Root relaxation: objective 3.720045e+03, 58008 iterations, 49.27 seconds (144.48 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.04500    0 50171 3732.89000 3720.04500  0.34%     -   50s #>  #> Explored 1 nodes (58105 simplex iterations) in 50.55 seconds (146.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.89 3732.9  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732890000000e+03, best bound 3.720045002821e+03, gap 0.3441%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results. Map potential locked-areas. Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Map proposed solution locked-areas. Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_sf, 20, 95)  # Plot fake locked-out area plot(no_protection, main = NULL, border = F) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218035 nonzeros #> Model fingerprint: 0x908efcd6 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8450000 #> Presolve removed 2781 rows and 1608 columns #> Presolve time: 0.64s #> Presolved: 74200 rows, 54562 columns, 211019 nonzeros #> Variable types: 0 continuous, 54562 integer (54562 binary) #> Root relaxation presolved: 74200 rows, 54562 columns, 211019 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    79902    3.7235278e+03   0.000000e+00   1.105348e+03      5s #>    88841    3.7209518e+03   0.000000e+00   3.043537e+03     10s #>    93297    3.7199971e+03   0.000000e+00   3.033930e+03     15s #>    97537    3.7198826e+03   0.000000e+00   6.369931e+02     20s #>   101633    3.7198377e+03   0.000000e+00   1.484675e+04     25s #>   105681    3.7198301e+03   0.000000e+00   1.369798e+03     30s #> Concurrent spin time: 1.31s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    41579    3.7198669e+03   0.000000e+00   0.000000e+00     32s #>  #> Root relaxation: objective 3.719867e+03, 41579 iterations, 30.79 seconds (90.95 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3719.86693    0 49565 3732.84500 3719.86693  0.35%     -   31s #>  #> Explored 1 nodes (41687 simplex iterations) in 31.89 seconds (92.79 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3732.85  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732845000000e+03, best bound 3.719866927108e+03, gap 0.3477%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas. Map proposed solution locked-locked-areas. looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76982 rows, 56170 columns and 218436 nonzeros #> Model fingerprint: 0xf4048946 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.9700000 #> Presolve removed 4318 rows and 2857 columns #> Presolve time: 0.81s #> Presolved: 72664 rows, 53313 columns, 206757 nonzeros #> Variable types: 0 continuous, 53313 integer (53313 binary) #> Found heuristic solution: objective 3732.9650000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 72330 rows, 53313 columns, 205755 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    73407    3.7242230e+03   0.000000e+00   2.207557e+03      5s #>    82887    3.7230283e+03   0.000000e+00   1.081976e+03     10s #>    94453    3.7219914e+03   0.000000e+00   8.368012e+04     15s #>   104318    3.7210228e+03   0.000000e+00   2.816210e+04     20s #>   108720    3.7204223e+03   0.000000e+00   8.221710e+03     25s #>   113456    3.7203600e+03   0.000000e+00   1.704823e+04     30s #>   119904    3.7201420e+03   0.000000e+00   1.317371e+04     35s #>   125763    3.7201045e+03   0.000000e+00   1.655345e+03     40s #>   128133    3.7200997e+03   0.000000e+00   2.980871e+03     45s #>   130433    3.7200965e+03   0.000000e+00   8.521033e+02     50s #> Concurrent spin time: 1.78s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    60783    3.7201850e+03   0.000000e+00   0.000000e+00     51s #>  #> Root relaxation: objective 3.720185e+03, 60783 iterations, 49.83 seconds (137.67 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.18505    0 48931 3732.96500 3720.18505  0.34%     -   51s #>  #> Explored 1 nodes (60901 simplex iterations) in 51.06 seconds (139.89 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.97 3732.97  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732965000000e+03, best bound 3.720185046242e+03, gap 0.3424%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Echelle S. Burns. Author, maintainer. Jason Flower. Author.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Burns E, Flower J (2024). patchwise: Create Patches Feature Groups Use Spatial Prioritizations. R package version 0.1.0, https://emlab-ucsb.github.io/patchwise/.","code":"@Manual{,   title = {patchwise: Create Patches of Feature Groups for Use in Spatial Prioritizations},   author = {Echelle S. Burns and Jason Flower},   year = {2024},   note = {R package version 0.1.0},   url = {https://emlab-ucsb.github.io/patchwise/}, }"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"patchwise-","dir":"","previous_headings":"","what":"Create Patches of Feature Groups for Use in Spatial Prioritizations","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"patchwise intended used supplementary package oceandatr (spatialgridr) instances users wish protect entire “chunks” areas using prioritizr. One example user wishes include seamounts feature protect prioritizr target 20% protection. Instead protecting little bit seamount 20% reached, patchwise makes easy ensure entire seamounts protected sequentially meet protection target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"can install development version patchwise GitHub : can install oceandatr spatialgridr GitHub :","code":"if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/patchwise\") if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/oceandatr\") devtools::install_github(\"emlab-ucsb/spatialgridr\")"},{"path":[]},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-raster-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using raster objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first.   Areas green identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts:  portions seamount units protected .","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]]  # Show what seamounts look like...  terra::plot(seamounts_rast) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast)  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast)  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast) # Grab all relevant data features_rast_nopatch <- oceandatr::get_features(spatial_grid = planning_rast)  # Run the prioritization problem_rast_nopatch <- prioritizr::problem(x = cost_rast, features = features_rast_nopatch) %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, terra::nlyr(features_rast_nopatch))) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_nopatch <- solve(problem_rast_nopatch)  # Show the results terra::plot(solution_nopatch)"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-sf-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using sf objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first.   Areas yellow identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts:  portions seamount units protected .","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_sf <- spatialgridr::get_grid(area, projection = projection, option = \"sf_square\")  # Grab all relevant data features_sf <- oceandatr::get_features(spatial_grid = planning_sf)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_sf <- features_sf %>%   dplyr::mutate(cost = 1) %>%   dplyr::select(cost)  # Separate seamount data - we want to protect entire patches seamounts_sf <- features_sf %>%    dplyr::select(seamounts)  features_sf <- features_sf %>%    dplyr::select(-seamounts)  # Show what seamounts look like...  plot(seamounts_sf, border = F) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf)  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf)  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, border = F) # Grab all relevant data features_sf_nopatch <- oceandatr::get_features(spatial_grid = planning_sf) %>%    dplyr::mutate(cost = 1) %>% # create a cost column   dplyr::relocate(cost, .before = x) # make sure cost column is before geometry column  # Run the prioritization problem_sf_nopatch <- prioritizr::problem(x = features_sf_nopatch, features = names(features_sf_nopatch)[1:(ncol(features_sf_nopatch)-1)], cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, ncol(features_sf_nopatch)-1)) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf_nopatch <- solve(problem_sf_nopatch)  # Show the results plot(solution_sf_nopatch %>% dplyr::select(solution_1), border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"function creates dataframe comibination feature targets, generated features_targets() targets constraints used prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"constraints_targets(feature_targets, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"feature_targets dataframe feature targets generated features_targets() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"dataframe used specify manual targets prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts prioritization solution into a more digestible output — convert_solution","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"function converts prioritization solution uses patches raster sf object (depending format spatial_grid) clearly marks areas suggested protection (1) areas suggested protection (0)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"convert_solution(solution, patch_df, spatial_grid)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"solution solution results using prioritizr::solve() prioritizr::problem() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"raster sf object denotes areas suggested protection (value = 1)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"if (FALSE) { # Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df) # Create prioritization problem problem_raster <- prioritizr::problem(x = patches_raster_df,   features = constraint_targets$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraint_targets) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix) %>%   prioritizr::add_default_solver(gap = 0.1, threads = parallel::detectCores()-1) # Solve problem solution <- solve(problem_raster) # Convert to a more digestible format suggested_protection <- convert_solution(solution = solution, patch_df = patches_raster_df,   spatial_grid = planning_raster) }"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"function creates boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"create_boundary_matrix(spatial_grid, patches, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object) patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"function takes inputs prioritizr creates dataframe precursor prioritizr. specific function includes use \"patches\" already generated create_patches(). \"Patches\" spatial groups particular feature, seamounts. Prioritizr protect entire patches meet protection goal feature. output function passed create_boundary_matrix() passed prioritizr.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"create_patch_df(   spatial_grid,   features,   patches,   costs = NULL,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch costs raster sf object costs protecting cell planning grid locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"data frame used input create_boundary_matrix()","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":null,"dir":"Reference","previous_headings":"","what":"Create patches for a specific feature — create_patches","title":"Create patches for a specific feature — create_patches","text":"function takes feature splits multiple \"patches\" feature. ideal features want protect x% , want make sure entire patches (opposed pieces patches) protected meet target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create patches for a specific feature — create_patches","text":"","code":"create_patches(feature, spatial_grid = NULL)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create patches for a specific feature — create_patches","text":"feature raster sf object feature interest present (value = 1) absent (value = NA) spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create patches for a specific feature — create_patches","text":"raster sf object independent layers (raster)/columns (sf) designating location patch","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create patches for a specific feature — create_patches","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for the relative and absolute targets for features — features_targets","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"function creates dataframe targets features used prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"features_targets(   targets,   features,   pre_patches,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"targets vector targets protection (range 0 1); must length number features + pre-patches variable features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature pre_patches raster sf object includes feature split patches (layer already split patches) locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"data frame used specify targets features. need plugged constraint_targets() implemented prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
