[{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  areas green selected prioritization protection. can clearly see locked-area (green square) included!","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]] # Create a function to produce a square area create_area <- function(spatial_grid, mpa_size, edge_offset) {    if(class(spatial_grid)[1] %in% c(\"RasterLayer\", \"SpatRaster\")) {      terra::rast(spatial_grid,                 vals = c(rep(NA, (terra::ncol(spatial_grid)*edge_offset)),                           rep(c(rep(NA, edge_offset),                                 rep(1, mpa_size),                                 rep(NA, (terra::ncol(spatial_grid)-(edge_offset+mpa_size)))),                               mpa_size),                           rep(NA, (terra::ncol(spatial_grid)*(terra::nrow(spatial_grid)-edge_offset-mpa_size)))))   } else if(class(spatial_grid)[1] == \"sf\") {      sf_to_grid <- sf::st_make_grid(spatial_grid, cellsize = sqrt(sf::st_area(spatial_grid[1,])))     sf_centroid <- sf::st_centroid(sf_to_grid) %>%        sf::st_coordinates(.) %>%        as.data.frame() %>%         dplyr::mutate(X = round(X, digits = 4),                      Y = round(Y, digits = 4))          # sf::st_make_grid changes the orientation of how cells are read - change them back     sf_to_grid <- sf_to_grid %>%        as.data.frame() %>%        dplyr::bind_cols(sf_centroid) %>%        dplyr::arrange(dplyr::desc(Y), X) %>%        dplyr::select(-X, -Y)          cols_sf_to_grid <- length(unique(sf_centroid$X))     rows_sf_to_grid <- length(unique(sf_centroid$Y))          sf_to_grid <- sf_to_grid %>%        sf::st_sf() %>%       dplyr::mutate(layer = c(rep(NA, (cols_sf_to_grid*edge_offset)),                           rep(c(rep(NA, edge_offset),                                 rep(1, mpa_size),                                 rep(NA, (cols_sf_to_grid-(edge_offset+mpa_size)))),                               mpa_size),                           rep(NA, (cols_sf_to_grid*(rows_sf_to_grid-edge_offset-mpa_size)))))          # the planning sf only includes polygons for the planning area (we need to remove them) so the number of cells matches the planning grid      sf_to_grid <- sf_to_grid[sf_to_grid$geometry %in% spatial_grid[[1]], ]     rownames(sf_to_grid) <- NULL     sf_to_grid %>%        dplyr::relocate(layer, 1)     } } # Create a fake MPA mpa_location <- create_area(planning_rast, 20, 50)  # Plot fake MPA terra::plot(mpa_location) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214386 nonzeros #> Model fingerprint: 0xc25c3da2 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3740.9750000 #> Presolve removed 2915 rows and 1615 columns #> Presolve time: 0.54s #> Presolved: 73381 rows, 54458 columns, 207121 nonzeros #> Variable types: 0 continuous, 54458 integer (54458 binary) #> Root relaxation presolved: 73381 rows, 54458 columns, 207121 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    80526    3.7266254e+03   0.000000e+00   4.169985e+03      5s #>    91183    3.7238091e+03   0.000000e+00   4.750069e+04     10s #>    96708    3.7230817e+03   0.000000e+00   4.072382e+03     15s #>   103658    3.7230201e+03   0.000000e+00   9.190971e+03     20s #>   111280    3.7228434e+03   0.000000e+00   2.703706e+04     25s #>   116031    3.7228387e+03   0.000000e+00   4.488749e+02     30s #>   119811    3.7228309e+03   0.000000e+00   2.887303e+03     35s #>   123041    3.7228279e+03   0.000000e+00   7.096251e+02     40s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    69647    3.7229317e+03   0.000000e+00   0.000000e+00     40s #>  #> Root relaxation: objective 3.722932e+03, 69647 iterations, 39.81 seconds (151.93 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3722.93174    0 50601 3740.97500 3722.93174  0.48%     -   40s #>  #> Explored 1 nodes (69735 simplex iterations) in 40.69 seconds (153.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3740.98  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.740975000000e+03, best bound 3.722931735863e+03, gap 0.4823%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_rast, 20, 95)  # Plot fake locked-out area terra::plot(no_protection) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214385 nonzeros #> Model fingerprint: 0xf7b92fc5 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3733.8850000 #> Presolve removed 2633 rows and 1557 columns #> Presolve time: 0.45s #> Presolved: 73663 rows, 54516 columns, 207723 nonzeros #> Variable types: 0 continuous, 54516 integer (54516 binary) #> Root relaxation presolved: 73663 rows, 54516 columns, 207723 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    83758    3.7256118e+03   0.000000e+00   2.342746e+03      5s #>    92663    3.7235696e+03   0.000000e+00   1.303630e+03     10s #>    98398    3.7226996e+03   0.000000e+00   1.479564e+04     15s #>   104828    3.7216976e+03   0.000000e+00   2.447515e+04     20s #>   110018    3.7215943e+03   0.000000e+00   1.682900e+04     25s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    55179    3.7213346e+03   0.000000e+00   0.000000e+00     27s #>  #> Root relaxation: objective 3.721335e+03, 55179 iterations, 26.01 seconds (101.60 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3721.33461    0 49528 3733.88500 3721.33461  0.34%     -   26s #>  #> Explored 1 nodes (55285 simplex iterations) in 26.85 seconds (103.27 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3733.89  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.733885000000e+03, best bound 3.721335000000e+03, gap 0.3361%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas.  looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76297 rows, 56073 columns and 214786 nonzeros #> Model fingerprint: 0x8acc3e12 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3741.0600000 #> Presolve removed 4596 rows and 2855 columns #> Presolve time: 0.49s #> Presolved: 71701 rows, 53218 columns, 202309 nonzeros #> Variable types: 0 continuous, 53218 integer (53218 binary) #> Root relaxation presolved: 71701 rows, 53218 columns, 202309 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    80419    3.7273666e+03   0.000000e+00   5.651829e+02      5s #>    92879    3.7259265e+03   0.000000e+00   1.045844e+03     10s #>   106657    3.7231162e+03   0.000000e+00   2.218551e+06     15s #>   112827    3.7230460e+03   0.000000e+00   1.086670e+03     20s #>   118156    3.7230298e+03   0.000000e+00   1.626549e+03     25s #>   122922    3.7230073e+03   0.000000e+00   1.326055e+03     30s #>   126426    3.7229918e+03   0.000000e+00   2.444874e+03     35s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    64341    3.7230710e+03   0.000000e+00   0.000000e+00     38s #>  #> Root relaxation: objective 3.723071e+03, 64341 iterations, 37.69 seconds (144.87 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3723.07098    0 49364 3741.06000 3723.07098  0.48%     -   38s #>  #> Explored 1 nodes (64433 simplex iterations) in 38.54 seconds (146.66 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3741.06  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.741060000000e+03, best bound 3.723070980814e+03, gap 0.4809%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  areas yellow selected prioritization protection. can clearly see locked-area (yellow square) included!","code":"# Create a fake MPA mpa_location <- create_area(planning_sf, 20, 50)  # Plot fake MPA plot(mpa_location, main = NULL, border = F) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218036 nonzeros #> Model fingerprint: 0xfea2ae20 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8950000 #> Presolve removed 2637 rows and 1617 columns #> Presolve time: 0.68s #> Presolved: 74344 rows, 54553 columns, 211669 nonzeros #> Variable types: 0 continuous, 54553 integer (54553 binary) #> Found heuristic solution: objective 3732.8900000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 74010 rows, 54553 columns, 210667 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    77171    3.7230465e+03   0.000000e+00   6.588938e+04      5s #>    88060    3.7221300e+03   0.000000e+00   1.350597e+03     10s #>    95540    3.7208894e+03   0.000000e+00   5.482002e+03     15s #>   101544    3.7206377e+03   0.000000e+00   2.612928e+03     20s #>   110098    3.7199967e+03   0.000000e+00   1.691474e+03     25s #>   115980    3.7199803e+03   0.000000e+00   1.270112e+03     30s #>   119886    3.7199605e+03   0.000000e+00   1.746472e+03     35s #>   122996    3.7199421e+03   0.000000e+00   2.585561e+02     40s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    58008    3.7200450e+03   0.000000e+00   0.000000e+00     40s #>  #> Root relaxation: objective 3.720045e+03, 58008 iterations, 39.58 seconds (144.48 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.04500    0 50171 3732.89000 3720.04500  0.34%     -   40s #>  #> Explored 1 nodes (58105 simplex iterations) in 40.59 seconds (146.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.89 3732.9  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732890000000e+03, best bound 3.720045002821e+03, gap 0.3441%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_sf, 20, 95)  # Plot fake locked-out area plot(no_protection, main = NULL, border = F) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218035 nonzeros #> Model fingerprint: 0x908efcd6 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8450000 #> Presolve removed 2781 rows and 1608 columns #> Presolve time: 0.51s #> Presolved: 74200 rows, 54562 columns, 211019 nonzeros #> Variable types: 0 continuous, 54562 integer (54562 binary) #> Root relaxation presolved: 74200 rows, 54562 columns, 211019 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    82960    3.7223640e+03   0.000000e+00   5.234564e+03      5s #>    91837    3.7202701e+03   0.000000e+00   1.046738e+03     10s #>    97231    3.7198831e+03   0.000000e+00   4.736830e+04     15s #>   102513    3.7198364e+03   0.000000e+00   1.435835e+05     20s #> Concurrent spin time: 0.59s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    41579    3.7198669e+03   0.000000e+00   0.000000e+00     24s #>  #> Root relaxation: objective 3.719867e+03, 41579 iterations, 23.36 seconds (90.95 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3719.86693    0 49565 3732.84500 3719.86693  0.35%     -   24s #>  #> Explored 1 nodes (41687 simplex iterations) in 24.21 seconds (92.79 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3732.85  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732845000000e+03, best bound 3.719866927108e+03, gap 0.3477%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas.  looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76982 rows, 56170 columns and 218436 nonzeros #> Model fingerprint: 0xf4048946 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.9700000 #> Presolve removed 4318 rows and 2857 columns #> Presolve time: 0.68s #> Presolved: 72664 rows, 53313 columns, 206757 nonzeros #> Variable types: 0 continuous, 53313 integer (53313 binary) #> Found heuristic solution: objective 3732.9650000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 72330 rows, 53313 columns, 205755 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    76333    3.7236546e+03   0.000000e+00   3.437098e+05      5s #>    88928    3.7227102e+03   0.000000e+00   1.231647e+03     10s #>   103756    3.7213043e+03   0.000000e+00   9.997892e+03     15s #>   109798    3.7203893e+03   0.000000e+00   5.309546e+04     20s #>   117803    3.7201587e+03   0.000000e+00   6.534543e+03     25s #>   125323    3.7201052e+03   0.000000e+00   6.760062e+03     30s #>   128493    3.7200993e+03   0.000000e+00   1.047685e+03     35s #> Concurrent spin time: 0.61s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    60783    3.7201850e+03   0.000000e+00   0.000000e+00     39s #>  #> Root relaxation: objective 3.720185e+03, 60783 iterations, 38.05 seconds (137.67 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.18505    0 48931 3732.96500 3720.18505  0.34%     -   39s #>  #> Explored 1 nodes (60901 simplex iterations) in 39.04 seconds (139.89 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.97 3732.97  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732965000000e+03, best bound 3.720185046242e+03, gap 0.3424%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Echelle Burns. Author, maintainer.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Burns E (2024). patchwise: Create Patches Feature Groups Use Spatial Prioritizations. R package version 0.1.0, https://emlab-ucsb.github.io/patchwise/.","code":"@Manual{,   title = {patchwise: Create Patches of Feature Groups for Use in Spatial Prioritizations},   author = {Echelle Burns},   year = {2024},   note = {R package version 0.1.0},   url = {https://emlab-ucsb.github.io/patchwise/}, }"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"patchwise","dir":"","previous_headings":"","what":"Create Patches of Feature Groups for Use in Spatial Prioritizations","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"patchwise intended used supplementary package oceandatr (spatialgridr) instances users wish protect entire “chunks” areas using prioritizr. One example user wishes include seamounts feature protect prioritizr target 20% protection. Instead protecting little bit seamount 20% reached, patchwise makes easy ensure entire seamounts protected sequentially meet protection target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"can install development version patchwise GitHub : can install oceandatr spatialgridr GitHub : examples, use prioritization optimizer gurobi, can found . Gurobi must installed device gurobi R package must also installed R can run prioritizr.","code":"if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/patchwise\") if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/oceandatr\") devtools::install_github(\"emlab-ucsb/spatialgridr\")"},{"path":[]},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-raster-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using raster objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first. Areas green identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts: portions seamount units protected .","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]]  # Show what seamounts look like...  terra::plot(seamounts_rast) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast)  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast)  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast) # Grab all relevant data features_rast_nopatch <- oceandatr::get_features(spatial_grid = planning_rast)  # Run the prioritization problem_rast_nopatch <- prioritizr::problem(x = cost_rast, features = features_rast_nopatch) %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, terra::nlyr(features_rast_nopatch))) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_nopatch <- solve(problem_rast_nopatch)  # Show the results terra::plot(solution_nopatch)"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-sf-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using sf objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first. Areas yellow identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts: portions seamount units protected .","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_sf <- spatialgridr::get_grid(area, projection = projection, option = \"sf_square\")  # Grab all relevant data features_sf <- oceandatr::get_features(spatial_grid = planning_sf)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_sf <- features_sf %>%   dplyr::mutate(cost = 1) %>%   dplyr::select(cost)  # Separate seamount data - we want to protect entire patches seamounts_sf <- features_sf %>%    dplyr::select(seamounts)  features_sf <- features_sf %>%    dplyr::select(-seamounts)  # Show what seamounts look like...  plot(seamounts_sf, border = F) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf)  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf)  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, border = F) # Grab all relevant data features_sf_nopatch <- oceandatr::get_features(spatial_grid = planning_sf) %>%    dplyr::mutate(cost = 1) %>% # create a cost column   dplyr::relocate(cost, .before = x) # make sure cost column is before geometry column  # Run the prioritization problem_sf_nopatch <- prioritizr::problem(x = features_sf_nopatch, features = names(features_sf_nopatch)[1:(ncol(features_sf_nopatch)-1)], cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, ncol(features_sf_nopatch)-1)) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf_nopatch <- solve(problem_sf_nopatch)  # Show the results plot(solution_sf_nopatch %>% dplyr::select(solution_1), border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"function creates dataframe comibination feature targets, generated features_targets() targets constraints used prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"constraints_targets(feature_targets, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"feature_targets dataframe feature targets generated features_targets() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"dataframe used specify manual targets prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts prioritization solution into a more digestible output — convert_solution","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"function converts prioritization solution uses patches raster sf object (depending format spatial_grid) clearly marks areas suggested protection (1) areas suggested protection (0)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"convert_solution(solution, patch_df, spatial_grid)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"solution solution results using prioritizr::solve() prioritizr::problem() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"raster sf object denotes areas suggested protection (value = 1)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df) # Create prioritization problem problem_raster <- prioritizr::problem(x = patches_raster_df,   features = constraint_targets$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraint_targets) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1) #> Warning: `data` has unexpected values. #> ✖ If `data` is from an older version of prioritizr, then use #>   `boundary_matrix()` to recreate it. #> ℹ `x` might have spatially overlapping planning units. # Solve problem solution <- solve(problem_raster) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76295 rows, 56073 columns and 213985 nonzeros #> Model fingerprint: 0x3f39d706 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3733.6350000 #> Presolve removed 952 rows and 317 columns #> Presolve time: 0.48s #> Presolved: 75343 rows, 55756 columns, 212535 nonzeros #> Variable types: 0 continuous, 55756 integer (55756 binary) #> Root relaxation presolved: 75343 rows, 55756 columns, 212535 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    84397    3.7261655e+03   0.000000e+00   4.375845e+04      5s #>    95116    3.7247900e+03   0.000000e+00   3.433822e+03     10s #>   102028    3.7219391e+03   0.000000e+00   1.232931e+03     15s #>   108598    3.7216986e+03   0.000000e+00   2.682192e+03     20s #>   115266    3.7214453e+03   0.000000e+00   2.536798e+04     25s #>   120908    3.7212532e+03   0.000000e+00   1.725392e+05     30s #>   127322    3.7211680e+03   0.000000e+00   1.195761e+04     35s #>   130963    3.7211541e+03   0.000000e+00   6.248709e+04     40s #>   134868    3.7211099e+03   0.000000e+00   8.665098e+04     45s #>   138516    3.7210725e+03   0.000000e+00   6.396256e+02     50s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    73586    3.7211523e+03   0.000000e+00   0.000000e+00     52s #>  #> Root relaxation: objective 3.721152e+03, 73586 iterations, 51.10 seconds (199.15 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3721.15230    0 53807 3733.63500 3721.15230  0.33%     -   51s #>  #> Explored 1 nodes (73708 simplex iterations) in 51.93 seconds (200.83 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3733.64  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.733635000000e+03, best bound 3.721152297269e+03, gap 0.3343% # Convert to a more digestible format suggested_protection <- convert_solution(solution = solution, patch_df = patches_raster_df,   spatial_grid = planning_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"function creates boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"create_boundary_matrix(spatial_grid, patches, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object) patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//Rtmpdu5mQf/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-07 15:18:37.980666) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"function takes inputs prioritizr creates dataframe precursor prioritizr. specific function includes use \"patches\" already generated create_patches(). \"Patches\" spatial groups particular feature, seamounts. Prioritizr protect entire patches meet protection goal feature. output function passed create_boundary_matrix() passed prioritizr.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"create_patch_df(   spatial_grid,   features,   patches,   costs = NULL,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch costs raster sf object costs protecting cell planning grid locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"data frame used input create_boundary_matrix()","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//Rtmpdu5mQf/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-07 15:18:37.980666) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":null,"dir":"Reference","previous_headings":"","what":"Create patches for a specific feature — create_patches","title":"Create patches for a specific feature — create_patches","text":"function takes feature splits multiple \"patches\" feature. ideal features want protect x% , want make sure entire patches (opposed pieces patches) protected meet target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create patches for a specific feature — create_patches","text":"","code":"create_patches(feature, spatial_grid = NULL)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create patches for a specific feature — create_patches","text":"feature raster sf object feature interest present (value = 1) absent (value = NA) spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create patches for a specific feature — create_patches","text":"raster sf object independent layers (raster)/columns (sf) designating location patch","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create patches for a specific feature — create_patches","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//Rtmpdu5mQf/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-07 15:18:37.980666) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for the relative and absolute targets for features — features_targets","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"function creates dataframe targets features used prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"features_targets(   targets,   features,   pre_patches,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"targets vector targets protection (range 0 1); must length number features + pre-patches variable features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature pre_patches raster sf object includes feature split patches (layer already split patches) locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"data frame used specify targets features. need plugged constraint_targets() implemented prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//Rtmpdu5mQf/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-07 15:18:37.980666) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
