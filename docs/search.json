[{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  areas green selected prioritization protection. can clearly see locked-area (green square) included!","code":"# Load libraries library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]] # Create a function to produce a square area create_area <- function(spatial_grid, mpa_size, edge_offset) {    if(class(spatial_grid)[1] %in% c(\"RasterLayer\", \"SpatRaster\")) {      terra::rast(spatial_grid,                 vals = c(rep(NA, (terra::ncol(spatial_grid)*edge_offset)),                           rep(c(rep(NA, edge_offset),                                 rep(1, mpa_size),                                 rep(NA, (terra::ncol(spatial_grid)-(edge_offset+mpa_size)))),                               mpa_size),                           rep(NA, (terra::ncol(spatial_grid)*(terra::nrow(spatial_grid)-edge_offset-mpa_size)))))   } else if(class(spatial_grid)[1] == \"sf\") {      sf_to_grid <- sf::st_make_grid(spatial_grid, cellsize = sqrt(sf::st_area(spatial_grid[1,])))     sf_centroid <- sf::st_centroid(sf_to_grid) %>%        sf::st_coordinates(.) %>%        as.data.frame() %>%         dplyr::mutate(X = round(X, digits = 4),                      Y = round(Y, digits = 4))          # sf::st_make_grid changes the orientation of how cells are read - change them back     sf_to_grid <- sf_to_grid %>%        as.data.frame() %>%        dplyr::bind_cols(sf_centroid) %>%        dplyr::arrange(dplyr::desc(Y), X) %>%        dplyr::select(-X, -Y)          cols_sf_to_grid <- length(unique(sf_centroid$X))     rows_sf_to_grid <- length(unique(sf_centroid$Y))          sf_to_grid <- sf_to_grid %>%        sf::st_sf() %>%       dplyr::mutate(layer = c(rep(NA, (cols_sf_to_grid*edge_offset)),                           rep(c(rep(NA, edge_offset),                                 rep(1, mpa_size),                                 rep(NA, (cols_sf_to_grid-(edge_offset+mpa_size)))),                               mpa_size),                           rep(NA, (cols_sf_to_grid*(rows_sf_to_grid-edge_offset-mpa_size)))))          # the planning sf only includes polygons for the planning area (we need to remove them) so the number of cells matches the planning grid      sf_to_grid <- sf_to_grid[sf_to_grid$geometry %in% spatial_grid[[1]], ]     rownames(sf_to_grid) <- NULL     sf_to_grid %>%        dplyr::relocate(layer, 1)     } } # Create a fake MPA mpa_location <- create_area(planning_rast, 20, 50)  # Plot fake MPA terra::plot(mpa_location) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214386 nonzeros #> Model fingerprint: 0xc25c3da2 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3740.9750000 #> Presolve removed 2915 rows and 1615 columns #> Presolve time: 0.73s #> Presolved: 73381 rows, 54458 columns, 207121 nonzeros #> Variable types: 0 continuous, 54458 integer (54458 binary) #> Root relaxation presolved: 73381 rows, 54458 columns, 207121 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    75213    3.7292223e+03   0.000000e+00   2.789111e+03      5s #>    87728    3.7247301e+03   0.000000e+00   1.163946e+03     10s #>    92403    3.7234152e+03   0.000000e+00   1.845726e+03     15s #>    96928    3.7230790e+03   0.000000e+00   3.650962e+03     20s #>   102263    3.7230237e+03   0.000000e+00   3.047628e+04     25s #>   108682    3.7228560e+03   0.000000e+00   5.559902e+03     30s #>   112725    3.7228415e+03   0.000000e+00   7.076330e+04     35s #>   116651    3.7228349e+03   0.000000e+00   5.104532e+04     40s #>   119311    3.7228313e+03   0.000000e+00   2.999021e+03     45s #>   121651    3.7228295e+03   0.000000e+00   6.317554e+02     50s #> Concurrent spin time: 0.02s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    69647    3.7229317e+03   0.000000e+00   0.000000e+00     53s #>  #> Root relaxation: objective 3.722932e+03, 69647 iterations, 52.00 seconds (151.93 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3722.93174    0 50601 3740.97500 3722.93174  0.48%     -   53s #>  #> Explored 1 nodes (69735 simplex iterations) in 53.18 seconds (153.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3740.98  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.740975000000e+03, best bound 3.722931735863e+03, gap 0.4823%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_rast, 20, 95)  # Plot fake locked-out area terra::plot(no_protection) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76296 rows, 56073 columns and 214385 nonzeros #> Model fingerprint: 0xf7b92fc5 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3733.8850000 #> Presolve removed 2633 rows and 1557 columns #> Presolve time: 0.58s #> Presolved: 73663 rows, 54516 columns, 207723 nonzeros #> Variable types: 0 continuous, 54516 integer (54516 binary) #> Root relaxation presolved: 73663 rows, 54516 columns, 207723 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    80503    3.7267058e+03   0.000000e+00   9.319456e+02      5s #>    89183    3.7240572e+03   0.000000e+00   1.563903e+03     10s #>    94213    3.7235126e+03   0.000000e+00   1.365684e+03     15s #>    98398    3.7226996e+03   0.000000e+00   1.479564e+04     20s #>   102133    3.7219730e+03   0.000000e+00   7.732695e+03     25s #>   107398    3.7216625e+03   0.000000e+00   8.573821e+02     30s #>   110828    3.7214911e+03   0.000000e+00   2.892824e+03     35s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    55179    3.7213346e+03   0.000000e+00   0.000000e+00     36s #>  #> Root relaxation: objective 3.721335e+03, 55179 iterations, 35.78 seconds (101.60 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3721.33461    0 49528 3733.88500 3721.33461  0.34%     -   36s #>  #> Explored 1 nodes (55285 simplex iterations) in 36.86 seconds (103.27 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3733.89  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.733885000000e+03, best bound 3.721335000000e+03, gap 0.3361%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-a-raster-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using a raster input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas.  looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76297 rows, 56073 columns and 214786 nonzeros #> Model fingerprint: 0x8acc3e12 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3741.0600000 #> Presolve removed 4596 rows and 2855 columns #> Presolve time: 0.65s #> Presolved: 71701 rows, 53218 columns, 202309 nonzeros #> Variable types: 0 continuous, 53218 integer (53218 binary) #> Root relaxation presolved: 71701 rows, 53218 columns, 202309 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    77801    3.7276475e+03   0.000000e+00   1.812350e+03      5s #>    86281    3.7269675e+03   0.000000e+00   3.586826e+02     10s #>    96403    3.7257502e+03   0.000000e+00   3.500927e+03     15s #>   106503    3.7231165e+03   0.000000e+00   2.218578e+06     20s #>   111235    3.7230565e+03   0.000000e+00   1.763970e+03     25s #>   115800    3.7230378e+03   0.000000e+00   1.658229e+03     30s #>   119076    3.7230250e+03   0.000000e+00   5.543245e+02     35s #>   122672    3.7230076e+03   0.000000e+00   1.493952e+03     40s #>   125436    3.7229934e+03   0.000000e+00   1.390157e+03     45s #>   127676    3.7229895e+03   0.000000e+00   6.278646e+02     50s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    64341    3.7230710e+03   0.000000e+00   0.000000e+00     51s #>  #> Root relaxation: objective 3.723071e+03, 64341 iterations, 50.58 seconds (144.87 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3723.07098    0 49364 3741.06000 3723.07098  0.48%     -   51s #>  #> Explored 1 nodes (64433 simplex iterations) in 51.70 seconds (146.66 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3741.06  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.741060000000e+03, best bound 3.723070980814e+03, gap 0.4809%  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"generate data example, use data Bermuda generated via oceandatr. can generate locked-layer represent existing MPA.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts).  areas yellow selected prioritization protection. can clearly see locked-area (yellow square) included!","code":"# Create a fake MPA mpa_location <- create_area(planning_sf, 20, 50)  # Plot fake MPA plot(mpa_location, main = NULL, border = F) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218036 nonzeros #> Model fingerprint: 0xfea2ae20 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8950000 #> Presolve removed 2637 rows and 1617 columns #> Presolve time: 0.87s #> Presolved: 74344 rows, 54553 columns, 211669 nonzeros #> Variable types: 0 continuous, 54553 integer (54553 binary) #> Found heuristic solution: objective 3732.8900000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 74010 rows, 54553 columns, 210667 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    73438    3.7232741e+03   0.000000e+00   2.463629e+03      5s #>    83438    3.7226878e+03   0.000000e+00   1.125802e+04     10s #>    90534    3.7220374e+03   0.000000e+00   4.925018e+03     15s #>    95780    3.7208750e+03   0.000000e+00   5.463111e+03     20s #>   100604    3.7206460e+03   0.000000e+00   2.149428e+03     25s #>   106034    3.7200822e+03   0.000000e+00   3.551270e+03     30s #>   112440    3.7199918e+03   0.000000e+00   1.828958e+05     35s #>   116340    3.7199773e+03   0.000000e+00   6.657439e+03     40s #>   119526    3.7199618e+03   0.000000e+00   1.319917e+03     45s #>   121766    3.7199549e+03   0.000000e+00   1.983493e+03     50s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    58008    3.7200450e+03   0.000000e+00   0.000000e+00     52s #>  #> Root relaxation: objective 3.720045e+03, 58008 iterations, 51.32 seconds (144.48 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.04500    0 50171 3732.89000 3720.04500  0.34%     -   52s #>  #> Explored 1 nodes (58105 simplex iterations) in 52.63 seconds (146.73 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.89 3732.9  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732890000000e+03, best bound 3.720045002821e+03, gap 0.3441%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"want note area consider protection? can include “locked-” area. repeat example , time exclude area prioritization results.  Now can continue using patchwise group seamount areas entire seamount ranges protected (portions seamounts). Great! area don’t want include solution removed!","code":"# Create a fake locked-out area no_protection <- create_area(planning_sf, 20, 95)  # Plot fake locked-out area plot(no_protection, main = NULL, border = F) # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76981 rows, 56170 columns and 218035 nonzeros #> Model fingerprint: 0x908efcd6 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.8450000 #> Presolve removed 2781 rows and 1608 columns #> Presolve time: 0.66s #> Presolved: 74200 rows, 54562 columns, 211019 nonzeros #> Variable types: 0 continuous, 54562 integer (54562 binary) #> Root relaxation presolved: 74200 rows, 54562 columns, 211019 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    79746    3.7235523e+03   0.000000e+00   1.061966e+03      5s #>    88529    3.7209551e+03   0.000000e+00   3.060026e+03     10s #>    92967    3.7199995e+03   0.000000e+00   3.016872e+03     15s #>    96763    3.7198853e+03   0.000000e+00   7.867408e+03     20s #>   101097    3.7198388e+03   0.000000e+00   3.377333e+04     25s #>   104743    3.7198308e+03   0.000000e+00   4.639173e+04     30s #> Concurrent spin time: 1.30s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    41579    3.7198669e+03   0.000000e+00   0.000000e+00     33s #>  #> Root relaxation: objective 3.719867e+03, 41579 iterations, 31.89 seconds (90.95 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3719.86693    0 49565 3732.84500 3719.86693  0.35%     -   32s #>  #> Explored 1 nodes (41687 simplex iterations) in 33.00 seconds (92.79 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3732.85  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732845000000e+03, best bound 3.719866927108e+03, gap 0.3477%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/articles/locked_in_out.html","id":"implement-locked-in-and-locked-out-areas-using-an-sf-input","dir":"Articles","previous_headings":"","what":"Implement locked-in and locked-out areas using an sf input","title":"Using patchwise with locked-in and locked-out areas","text":"can also run scenario locked-locked-areas.  looks like got results wanted - locked-areas included prioritization output area protect, locked-areas included!","code":"# Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf, locked_in = mpa_location, locked_out = no_protection) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\"  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf, locked_in = mpa_location, locked_out = no_protection)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76982 rows, 56170 columns and 218436 nonzeros #> Model fingerprint: 0xf4048946 #> Variable types: 0 continuous, 56170 integer (56170 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 6e+02] #>   Objective range  [2e-02, 6e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3732.9700000 #> Presolve removed 4318 rows and 2857 columns #> Presolve time: 0.90s #> Presolved: 72664 rows, 53313 columns, 206757 nonzeros #> Variable types: 0 continuous, 53313 integer (53313 binary) #> Found heuristic solution: objective 3732.9650000 #> Root relaxation presolve removed 334 rows and 0 columns #> Root relaxation presolved: 72330 rows, 53313 columns, 205755 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.25 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    72945    3.7242572e+03   0.000000e+00   2.489007e+03      5s #>    82477    3.7230293e+03   0.000000e+00   1.361611e+03     10s #>    93529    3.7221301e+03   0.000000e+00   7.914218e+02     15s #>   103462    3.7213169e+03   0.000000e+00   1.078376e+04     20s #>   107862    3.7204430e+03   0.000000e+00   7.707059e+04     25s #>   112370    3.7203633e+03   0.000000e+00   3.771695e+03     30s #>   118782    3.7201490e+03   0.000000e+00   7.820055e+03     35s #>   124364    3.7201149e+03   0.000000e+00   9.206287e+03     40s #>   127393    3.7201007e+03   0.000000e+00   1.266398e+04     45s #>   129603    3.7200977e+03   0.000000e+00   4.353195e+04     50s #> Concurrent spin time: 1.66s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    60783    3.7201850e+03   0.000000e+00   0.000000e+00     53s #>  #> Root relaxation: objective 3.720185e+03, 60783 iterations, 51.61 seconds (137.67 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3720.18505    0 48931 3732.96500 3720.18505  0.34%     -   52s #>  #> Explored 1 nodes (60901 simplex iterations) in 52.92 seconds (139.89 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 2: 3732.97 3732.97  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.732965000000e+03, best bound 3.720185046242e+03, gap 0.3424%  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, main = NULL, border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Echelle Burns. Author, maintainer.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Burns E (2024). patchwise: Create Patches Feature Groups Use Spatial Prioritizations. R package version 0.1.0, https://emlab-ucsb.github.io/patchwise/.","code":"@Manual{,   title = {patchwise: Create Patches of Feature Groups for Use in Spatial Prioritizations},   author = {Echelle Burns},   year = {2024},   note = {R package version 0.1.0},   url = {https://emlab-ucsb.github.io/patchwise/}, }"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"patchwise","dir":"","previous_headings":"","what":"Create Patches of Feature Groups for Use in Spatial Prioritizations","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"patchwise intended used supplementary package oceandatr (spatialgridr) instances users wish protect entire “chunks” areas using prioritizr. One example user wishes include seamounts feature protect prioritizr target 20% protection. Instead protecting little bit seamount 20% reached, patchwise makes easy ensure entire seamounts protected sequentially meet protection target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"can install development version patchwise GitHub : can install oceandatr spatialgridr GitHub : examples, use prioritization optimizer gurobi, can found . Gurobi must installed device gurobi R package must also installed R can run prioritizr.","code":"if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/patchwise\") if (!require(devtools)) install.packages(\"devtools\") devtools::install_github(\"emlab-ucsb/oceandatr\") devtools::install_github(\"emlab-ucsb/spatialgridr\")"},{"path":[]},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-raster-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using raster objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first. Areas green identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts: portions seamount units protected .","code":"# Load libraries library(tidyverse) library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_rast <- spatialgridr::get_grid(area, projection = projection)  # Grab all relevant data features_rast <- oceandatr::get_features(spatial_grid = planning_rast)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_rast <- stats::setNames(planning_rast, \"cost\")  # Separate seamount data - we want to protect entire patches seamounts_rast <- features_rast[[\"seamounts\"]] features_rast <- features_rast[[names(features_rast)[names(features_rast) != \"seamounts\"]]]  # Show what seamounts look like...  terra::plot(seamounts_rast) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_rast <- patchwise::create_patches(seamounts_rast)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_rast <- patchwise::create_patch_df(spatial_grid = planning_rast, features = features_rast, patches = patches_rast, costs = cost_rast)  # Create boundary matrix for prioritizr boundary_matrix_rast <- patchwise::create_boundary_matrix(spatial_grid = planning_rast, patches = patches_rast, patch_df = patches_df_rast)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_rast <- patchwise::features_targets(targets = rep(0.2, (terra::nlyr(features_rast) + 1)), features = features_rast, pre_patches = seamounts_rast)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_rast <- patchwise::constraints_targets(feature_targets = targets_rast, patch_df = patches_df_rast)  # Run the prioritization problem_rast <- prioritizr::problem(x = patches_df_rast, features = constraints_rast$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_rast) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_rast) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_rast <- solve(problem_rast)  # Convert the prioritization into a more digestible format result_rast <- patchwise::convert_solution(solution = solution_rast, patch_df = patches_df_rast, spatial_grid = planning_rast)  # Show the results terra::plot(result_rast) # Grab all relevant data features_rast_nopatch <- oceandatr::get_features(spatial_grid = planning_rast)  # Run the prioritization problem_rast_nopatch <- prioritizr::problem(x = cost_rast, features = features_rast_nopatch) %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, terra::nlyr(features_rast_nopatch))) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_nopatch <- solve(problem_rast_nopatch)  # Show the results terra::plot(solution_nopatch)"},{"path":"https://emlab-ucsb.github.io/patchwise/index.html","id":"using-sf-objects-as-inputs","dir":"","previous_headings":"Examples of usage","what":"Using sf objects as inputs","title":"Create Patches of Feature Groups for Use in Spatial Prioritizations","text":"Since package intended used combination oceandatr, several housekeeping steps need completed first. Areas yellow identified prioritizr areas worth protecting. can see entire seamounts used meet target objective protecting 20% seamounts. can compare result prioritizr run protect whole seamounts: portions seamount units protected .","code":"# Load libraries library(tidyverse) library(patchwise)  # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <- '+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs'  # Create a planning grid planning_sf <- spatialgridr::get_grid(area, projection = projection, option = \"sf_square\")  # Grab all relevant data features_sf <- oceandatr::get_features(spatial_grid = planning_sf)  # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_sf <- features_sf %>%   dplyr::mutate(cost = 1) %>%   dplyr::select(cost)  # Separate seamount data - we want to protect entire patches seamounts_sf <- features_sf %>%    dplyr::select(seamounts)  features_sf <- features_sf %>%    dplyr::select(-seamounts)  # Show what seamounts look like...  plot(seamounts_sf, border = F) # there are 7 seamount areas (seamounts that are touching) # Create seamount patches - seamount areas that touch are considered the same patch patches_sf <- patchwise::create_patches(seamounts_sf, spatial_grid = planning_sf)  # Create patches dataframe - this creates several constraints so that entire seamount units are protected together patches_df_sf <- patchwise::create_patch_df(spatial_grid = planning_sf, features = features_sf, patches = patches_sf, costs = cost_sf)  # Create boundary matrix for prioritizr boundary_matrix_sf <- patchwise::create_boundary_matrix(spatial_grid = planning_sf, patches = patches_sf, patch_df = patches_df_sf)  # Create targets for protection - let's just do 20% for each feature (including 20% of whole seamounts) targets_sf <- patchwise::features_targets(targets = rep(0.2, ncol(features_sf)), features = features_sf, pre_patches = seamounts_sf)  # Add these targets to targets for protection for the \"constraints\" we introduced to protect entire seamount units constraints_sf <- patchwise::constraints_targets(feature_targets = targets_sf, patch_df = patches_df_sf)  # Run the prioritization problem_sf <- prioritizr::problem(x = patches_df_sf, features = constraints_sf$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraints_sf) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix_sf) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf <- solve(problem_sf)  # Convert the prioritization into a more digestible format result_sf <- patchwise::convert_solution(solution = solution_sf, patch_df = patches_df_sf, spatial_grid = planning_sf)  # Show the results plot(result_sf, border = F) # Grab all relevant data features_sf_nopatch <- oceandatr::get_features(spatial_grid = planning_sf) %>%    dplyr::mutate(cost = 1) %>% # create a cost column   dplyr::relocate(cost, .before = x) # make sure cost column is before geometry column  # Run the prioritization problem_sf_nopatch <- prioritizr::problem(x = features_sf_nopatch, features = names(features_sf_nopatch)[1:(ncol(features_sf_nopatch)-1)], cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_relative_targets(rep(0.2, ncol(features_sf_nopatch)-1)) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1)  # Solve the prioritization solution_sf_nopatch <- solve(problem_sf_nopatch)  # Show the results plot(solution_sf_nopatch %>% dplyr::select(solution_1), border = F)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"function creates dataframe comibination feature targets, generated features_targets() targets constraints used prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"constraints_targets(feature_targets, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"feature_targets dataframe feature targets generated features_targets() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"dataframe used specify manual targets prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/constraints_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for manual targets for all layers, including the features and the constraints — constraints_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts prioritization solution into a more digestible output — convert_solution","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"function converts prioritization solution uses patches raster sf object (depending format spatial_grid) clearly marks areas suggested protection (1) areas suggested protection (0)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"convert_solution(solution, patch_df, spatial_grid)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"solution solution results using prioritizr::solve() prioritizr::problem() patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"raster sf object denotes areas suggested protection (value = 1)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/convert_solution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts prioritization solution into a more digestible output — convert_solution","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster) # Create constraint targets constraint_targets <- constraints_targets(feature_targets = features_targets,   patch_df = patches_raster_df) # Create prioritization problem problem_raster <- prioritizr::problem(x = patches_raster_df,   features = constraint_targets$feature, cost_column = \"cost\") %>%   prioritizr::add_min_set_objective() %>%   prioritizr::add_manual_targets(constraint_targets) %>%   prioritizr::add_binary_decisions() %>%   prioritizr::add_boundary_penalties(penalty = 0.000002, data = boundary_matrix) %>%   prioritizr::add_gurobi_solver(gap = 0.1, threads = parallel::detectCores()-1) #> Warning: `data` has unexpected values. #> ✖ If `data` is from an older version of prioritizr, then use #>   `boundary_matrix()` to recreate it. #> ℹ `x` might have spatially overlapping planning units. # Solve problem solution <- solve(problem_raster) #> Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (mac64[arm]) #>  #> CPU model: Apple M1 Max #> Thread count: 10 physical cores, 10 logical processors, using up to 9 threads #>  #> Optimize a model with 76295 rows, 56073 columns and 213985 nonzeros #> Model fingerprint: 0x3f39d706 #> Variable types: 0 continuous, 56073 integer (56073 binary) #> Coefficient statistics: #>   Matrix range     [1e+00, 5e+02] #>   Objective range  [2e-02, 5e+02] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [1e+00, 4e+03] #> Found heuristic solution: objective 3733.6350000 #> Presolve removed 952 rows and 317 columns #> Presolve time: 0.65s #> Presolved: 75343 rows, 55756 columns, 212535 nonzeros #> Variable types: 0 continuous, 55756 integer (55756 binary) #> Root relaxation presolved: 75343 rows, 55756 columns, 212535 nonzeros #>  #> Deterministic concurrent LP optimizer: primal and dual simplex #> Showing first log only... #>  #> Warning: Markowitz tolerance tightened to 0.5 #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    81717    3.7266026e+03   0.000000e+00   8.637269e+04      5s #>    90186    3.7250921e+03   0.000000e+00   5.624945e+02     10s #>    96737    3.7244806e+03   0.000000e+00   4.932777e+03     15s #>   101888    3.7222072e+03   0.000000e+00   2.026896e+03     20s #>   106231    3.7217633e+03   0.000000e+00   3.101825e+03     25s #>   111180    3.7215697e+03   0.000000e+00   7.192133e+04     30s #>   116310    3.7214399e+03   0.000000e+00   2.278027e+03     35s #>   119815    3.7212926e+03   0.000000e+00   1.413697e+04     40s #>   125318    3.7212303e+03   0.000000e+00   8.006232e+04     45s #>   128993    3.7211630e+03   0.000000e+00   1.287043e+04     50s #>   131620    3.7211514e+03   0.000000e+00   6.580413e+04     55s #>   134478    3.7211172e+03   0.000000e+00   7.146691e+04     60s #>   137429    3.7210766e+03   0.000000e+00   6.303001e+02     65s #> Concurrent spin time: 0.00s #>  #> Solved with dual simplex #>  #> Root simplex log... #>  #> Iteration    Objective       Primal Inf.    Dual Inf.      Time #>    73586    3.7211523e+03   0.000000e+00   0.000000e+00     69s #>  #> Root relaxation: objective 3.721152e+03, 73586 iterations, 67.94 seconds (199.15 work units) #>  #>     Nodes    |    Current Node    |     Objective Bounds      |     Work #>  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time #>  #>      0     0 3721.15230    0 53807 3733.63500 3721.15230  0.33%     -   69s #>  #> Explored 1 nodes (73708 simplex iterations) in 69.05 seconds (200.83 work units) #> Thread count was 9 (of 10 available processors) #>  #> Solution count 1: 3733.64  #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective 3.733635000000e+03, best bound 3.721152297269e+03, gap 0.3343% # Convert to a more digestible format suggested_protection <- convert_solution(solution = solution, patch_df = patches_raster_df,   spatial_grid = planning_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"function creates boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"create_boundary_matrix(spatial_grid, patches, patch_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object) patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch patch_df dataframe generated create_patch_df() includes constraints patch grid cell combination","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"boundary matrix plug prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_boundary_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create boundary matrix for prioritizr if you are using patches — create_boundary_matrix","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//RtmpD6Vrmp/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-06 14:19:47.679807) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster,   patches = patches_raster, patch_df = patches_raster_df)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"function takes inputs prioritizr creates dataframe precursor prioritizr. specific function includes use \"patches\" already generated create_patches(). \"Patches\" spatial groups particular feature, seamounts. Prioritizr protect entire patches meet protection goal feature. output function passed create_boundary_matrix() passed prioritizr.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"create_patch_df(   spatial_grid,   features,   patches,   costs = NULL,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature patches raster sf object generated create_patches(); single feature split spatially distinct groups; layer raster column sf object identifies location patch costs raster sf object costs protecting cell planning grid locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"data frame used input create_boundary_matrix()","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patch_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe that counts each patch independently for the prioritizr input — create_patch_df","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//RtmpD6Vrmp/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-06 14:19:47.679807) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":null,"dir":"Reference","previous_headings":"","what":"Create patches for a specific feature — create_patches","title":"Create patches for a specific feature — create_patches","text":"function takes feature splits multiple \"patches\" feature. ideal features want protect x% , want make sure entire patches (opposed pieces patches) protected meet target.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create patches for a specific feature — create_patches","text":"","code":"create_patches(feature, spatial_grid = NULL)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create patches for a specific feature — create_patches","text":"feature raster sf object feature interest present (value = 1) absent (value = NA) spatial_grid raster sf template desired resolution coordinate reference system generated spatialgridr::get_grid(); values areas interest 1, values NA (required feature sf object)","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create patches for a specific feature — create_patches","text":"raster sf object independent layers (raster)/columns (sf) designating location patch","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/create_patches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create patches for a specific feature — create_patches","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//RtmpD6Vrmp/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-06 14:19:47.679807) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dataframe for the relative and absolute targets for features — features_targets","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"function creates dataframe targets features used prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"features_targets(   targets,   features,   pre_patches,   locked_out = NULL,   locked_in = NULL )"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"targets vector targets protection (range 0 1); must length number features + pre-patches variable features raster sf object includes relevant features used prioritization; layer raster column sf object identifies location feature pre_patches raster sf object includes feature split patches (layer already split patches) locked_out raster sf object areas locked (absolutely protected) prioritization locked_in raster sf object areas locked (absolutely protected) prioritization","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"data frame used specify targets features. need plugged constraint_targets() implemented prioritizr","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/features_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dataframe for the relative and absolute targets for features — features_targets","text":"","code":"# Start with a little housekeeping to get the data from oceandatr # Choose area of interest (Bermuda EEZ) area <- oceandatr::get_area(area_name = \"Bermuda\",  mregions_column = \"territory1\") #> Cache is fresh. Reading: #> /var/folders/yg/bhr88yt91vj4bxq91bs_nx780000gn/T//RtmpD6Vrmp/eez-2205f12f/eez.shp #> (Last Modified: 2024-02-06 14:19:47.679807) projection <-'+proj=laea +lon_0=-64.8108333 +lat_0=32.3571917 +datum=WGS84 +units=m +no_defs' # Create a planning grid planning_raster <- spatialgridr::get_grid(area, projection = projection) # Grab all relevant data features_raster <- oceandatr::get_features(spatial_grid = planning_raster) #> Getting depth zones... #> This may take seconds to minutes, depending on grid size #> Getting seamount data... #> Spherical geometry (s2) switched off #> although coordinates are longitude/latitude, st_intersection assumes that they #> are planar #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Spherical geometry (s2) switched on #> Getting knoll data... #> Warning: attribute variables are assumed to be spatially constant throughout all geometries #> Getting geomorphology data... #> Getting coral data... #> |-- Coral data found for antipatharia coral, cold coral, octocoral #> Getting environmental regions data... This could take several minutes # Separate seamount data - we want to protect entire patches seamounts_raster <- features_raster[[\"seamounts\"]] features_raster <- features_raster[[names(features_raster)[names(features_raster) != \"seamounts\"]]] # Create a \"cost\" to protecting a cell - just a uniform cost for this example cost_raster <- stats::setNames(planning_raster, \"cost\") # Create patches from layer patches_raster <- create_patches(seamounts_raster) # Create patch dataframe patches_raster_df <- create_patch_df(spatial_grid = planning_raster, features = features_raster,   patches = patches_raster, costs = cost_raster) #> [1] \"Processing patch 1 of 7\" #> [1] \"Processing patch 2 of 7\" #> [1] \"Processing patch 3 of 7\" #> [1] \"Processing patch 4 of 7\" #> [1] \"Processing patch 5 of 7\" #> [1] \"Processing patch 6 of 7\" #> [1] \"Processing patch 7 of 7\" # Create boundary matrix for prioritizr boundary_matrix <- create_boundary_matrix(spatial_grid = planning_raster, patches = patches_raster,   patch_df = patches_raster_df) # Create target features - using just 20% for every feature features_targets <- features_targets(targets = rep(0.2, (terra::nlyr(features_raster)) + 1),   features = features_raster, pre_patches = seamounts_raster)"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://emlab-ucsb.github.io/patchwise/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
